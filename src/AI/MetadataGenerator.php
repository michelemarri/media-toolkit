<?php
/**
 * AI Metadata Generator - Batch processor for image analysis
 *
 * @package Metodo\MediaToolkit
 */

declare(strict_types=1);

namespace Metodo\MediaToolkit\AI;

use Metodo\MediaToolkit\Core\Logger;
use Metodo\MediaToolkit\Core\Settings;
use Metodo\MediaToolkit\History\History;
use Metodo\MediaToolkit\History\HistoryAction;
use Metodo\MediaToolkit\Migration\Batch_Processor;

/**
 * Batch processor for generating AI metadata for images
 */
final class MetadataGenerator extends Batch_Processor
{
    private AIManager $ai_manager;
    private ?History $history;

    /** @var string Cron hook for async processing */
    private const CRON_HOOK = 'media_toolkit_ai_metadata_async_batch';

    public function __construct(
        Logger $logger,
        Settings $settings,
        AIManager $ai_manager,
        ?History $history = null
    ) {
        parent::__construct($logger, $settings, 'ai_metadata');
        
        $this->ai_manager = $ai_manager;
        $this->history = $history;

        // Register cron handler for background processing
        add_action(self::CRON_HOOK, [$this, 'process_async_batch']);
    }

    protected function get_processor_name(): string
    {
        return 'AI Metadata Generator';
    }

    /**
     * Start batch processing
     * Override to support background mode scheduling
     * 
     * @param array $options Processing options
     * @return array Initial state
     */
    public function start(array $options = []): array
    {
        $state = parent::start($options);

        // If background mode is enabled, schedule the first cron event
        if (!empty($options['background_mode'])) {
            $this->schedule_async_batch();
            $this->logger->info('ai_metadata', 'Started in background mode - processing will continue without browser');
        }

        return $state;
    }

    /**
     * Get statistics about image metadata completeness
     */
    public function get_stats(): array
    {
        global $wpdb;
        
        // Total images
        $total_images = (int) $wpdb->get_var(
            "SELECT COUNT(*) FROM {$wpdb->posts} 
             WHERE post_type = 'attachment' 
             AND post_mime_type LIKE 'image/%'"
        );

        // Images with alt text
        $with_alt = (int) $wpdb->get_var(
            "SELECT COUNT(DISTINCT pm.post_id) 
             FROM {$wpdb->postmeta} pm
             INNER JOIN {$wpdb->posts} p ON pm.post_id = p.ID
             WHERE pm.meta_key = '_wp_attachment_image_alt' 
             AND pm.meta_value != ''
             AND p.post_type = 'attachment'
             AND p.post_mime_type LIKE 'image/%'"
        );

        // Images with title (post_title not empty and not just filename)
        $with_title = (int) $wpdb->get_var(
            "SELECT COUNT(*) FROM {$wpdb->posts} 
             WHERE post_type = 'attachment' 
             AND post_mime_type LIKE 'image/%'
             AND post_title != ''
             AND post_title NOT REGEXP '^[a-zA-Z0-9_-]+$'"
        );

        // Images with caption (post_excerpt)
        $with_caption = (int) $wpdb->get_var(
            "SELECT COUNT(*) FROM {$wpdb->posts} 
             WHERE post_type = 'attachment' 
             AND post_mime_type LIKE 'image/%'
             AND post_excerpt != ''"
        );

        // Images with description (post_content)
        $with_description = (int) $wpdb->get_var(
            "SELECT COUNT(*) FROM {$wpdb->posts} 
             WHERE post_type = 'attachment' 
             AND post_mime_type LIKE 'image/%'
             AND post_content != ''"
        );

        // Calculate percentages
        $pct_alt = $total_images > 0 ? round(($with_alt / $total_images) * 100) : 0;
        $pct_title = $total_images > 0 ? round(($with_title / $total_images) * 100) : 0;
        $pct_caption = $total_images > 0 ? round(($with_caption / $total_images) * 100) : 0;
        $pct_description = $total_images > 0 ? round(($with_description / $total_images) * 100) : 0;

        // Overall completeness (average of all fields)
        $overall = $total_images > 0 
            ? round(($pct_alt + $pct_title + $pct_caption + $pct_description) / 4) 
            : 0;

        // Images generated by AI
        $ai_generated = (int) $wpdb->get_var(
            "SELECT COUNT(DISTINCT post_id) FROM {$wpdb->postmeta} 
             WHERE meta_key = '_media_toolkit_ai_generated'"
        );

        return [
            'total_images' => $total_images,
            'with_alt_text' => $with_alt,
            'without_alt_text' => $total_images - $with_alt,
            'with_title' => $with_title,
            'without_title' => $total_images - $with_title,
            'with_caption' => $with_caption,
            'without_caption' => $total_images - $with_caption,
            'with_description' => $with_description,
            'without_description' => $total_images - $with_description,
            'pct_alt_text' => $pct_alt,
            'pct_title' => $pct_title,
            'pct_caption' => $pct_caption,
            'pct_description' => $pct_description,
            'overall_completeness' => $overall,
            'ai_generated_count' => $ai_generated,
        ];
    }

    /**
     * Estimate cost for processing images
     */
    public function estimate_cost(bool $only_empty = true): array
    {
        $count = $this->count_pending_items(['only_empty_fields' => $only_empty]);
        $estimate = $this->ai_manager->estimateCost($count);
        $estimate['images_count'] = $count;
        return $estimate;
    }

    /**
     * Get SQL WHERE clause for supported MIME types
     */
    private function get_supported_mime_clause(): string
    {
        return "p.post_mime_type IN ('image/jpeg', 'image/png', 'image/gif', 'image/webp')";
    }

    protected function count_pending_items(array $options = []): int
    {
        global $wpdb;

        $only_empty = $options['only_empty_fields'] ?? true;
        $mime_clause = $this->get_supported_mime_clause();

        if ($only_empty) {
            // Count images missing at least one field (only supported formats)
            return (int) $wpdb->get_var(
                "SELECT COUNT(*) FROM {$wpdb->posts} p
                 LEFT JOIN {$wpdb->postmeta} pm ON p.ID = pm.post_id AND pm.meta_key = '_wp_attachment_image_alt'
                 WHERE p.post_type = 'attachment' 
                 AND {$mime_clause}
                 AND (
                     pm.meta_value IS NULL 
                     OR pm.meta_value = ''
                     OR p.post_excerpt = ''
                     OR p.post_content = ''
                 )"
            );
        }

        // Count all images (only supported formats)
        return (int) $wpdb->get_var(
            "SELECT COUNT(*) FROM {$wpdb->posts} p
             WHERE p.post_type = 'attachment' 
             AND {$mime_clause}"
        );
    }

    protected function get_pending_items(int $limit, int $after_id, array $options = []): array
    {
        global $wpdb;

        $only_empty = $options['only_empty_fields'] ?? true;
        $mime_clause = $this->get_supported_mime_clause();

        if ($only_empty) {
            return $wpdb->get_results($wpdb->prepare(
                "SELECT p.ID, p.post_title, p.post_excerpt, p.post_content, pm.meta_value as alt_text
                 FROM {$wpdb->posts} p
                 LEFT JOIN {$wpdb->postmeta} pm ON p.ID = pm.post_id AND pm.meta_key = '_wp_attachment_image_alt'
                 WHERE p.post_type = 'attachment' 
                 AND {$mime_clause}
                 AND p.ID > %d
                 AND (
                     pm.meta_value IS NULL 
                     OR pm.meta_value = ''
                     OR p.post_excerpt = ''
                     OR p.post_content = ''
                 )
                 ORDER BY p.ID ASC
                 LIMIT %d",
                $after_id,
                $limit
            ), ARRAY_A);
        }

        return $wpdb->get_results($wpdb->prepare(
            "SELECT p.ID, p.post_title, p.post_excerpt, p.post_content, pm.meta_value as alt_text
             FROM {$wpdb->posts} p
             LEFT JOIN {$wpdb->postmeta} pm ON p.ID = pm.post_id AND pm.meta_key = '_wp_attachment_image_alt'
             WHERE p.post_type = 'attachment' 
             AND {$mime_clause}
             AND p.ID > %d
             ORDER BY p.ID ASC
             LIMIT %d",
            $after_id,
            $limit
        ), ARRAY_A);
    }

    /** @var array Supported image MIME types for AI analysis */
    private const SUPPORTED_MIME_TYPES = [
        'image/jpeg',
        'image/png',
        'image/gif',
        'image/webp',
    ];

    protected function process_item($item, array $options = []): array
    {
        $attachment_id = (int) $item['ID'];
        $overwrite = $options['overwrite'] ?? false;

        try {
            // Check if image format is supported by AI providers
            $mime_type = get_post_mime_type($attachment_id);
            if (!in_array($mime_type, self::SUPPORTED_MIME_TYPES, true)) {
                $this->logger->info(
                    'ai_metadata',
                    sprintf('Skipping #%d: unsupported format %s (supported: JPEG, PNG, GIF, WebP)', $attachment_id, $mime_type)
                );
                return [
                    'success' => true,
                    'skipped' => true,
                    'reason' => sprintf('Unsupported format: %s', $mime_type),
                ];
            }

            // Get image URL
            $image_url = $this->get_image_url($attachment_id);
            
            if (empty($image_url)) {
                return [
                    'success' => false,
                    'error' => 'Could not get image URL',
                ];
            }

            // Determine which fields need to be generated
            $needs_generation = $this->check_fields_to_generate($item, $overwrite);
            
            if (empty($needs_generation)) {
                return [
                    'success' => true,
                    'skipped' => true,
                ];
            }

            // Analyze image with AI
            $metadata = $this->ai_manager->analyzeImage($image_url);

            // Save metadata
            $this->save_metadata($attachment_id, $metadata, $item, $overwrite);

            // Mark as AI generated
            update_post_meta($attachment_id, '_media_toolkit_ai_generated', time());
            update_post_meta($attachment_id, '_media_toolkit_ai_provider', $metadata['provider'] ?? 'unknown');

            // Log to history
            $this->history?->record(
                HistoryAction::AI_METADATA_GENERATED,
                $attachment_id,
                get_attached_file($attachment_id),
                null,
                null,
                [
                    'provider' => $metadata['provider'] ?? 'unknown',
                    'fields_updated' => array_keys($needs_generation),
                ]
            );

            $this->logger->success(
                'ai_metadata',
                sprintf('Generated metadata for attachment #%d using %s', $attachment_id, $metadata['provider'] ?? 'unknown')
            );

            return [
                'success' => true,
                'provider' => $metadata['provider'] ?? 'unknown',
            ];

        } catch (AIProviderException $e) {
            $this->logger->error(
                'ai_metadata',
                sprintf('Failed to generate metadata for #%d: %s', $attachment_id, $e->getMessage())
            );

            return [
                'success' => false,
                'error' => $e->getMessage(),
                'retryable' => $e->isRetryable(),
            ];
        } catch (\Exception $e) {
            $this->logger->error(
                'ai_metadata',
                sprintf('Unexpected error for #%d: %s', $attachment_id, $e->getMessage())
            );

            return [
                'success' => false,
                'error' => $e->getMessage(),
            ];
        }
    }

    protected function get_item_id($item): int
    {
        return (int) $item['ID'];
    }

    /**
     * Get image URL for AI analysis
     */
    private function get_image_url(int $attachment_id): string
    {
        // Check if image is on cloud storage
        $cloud_url = get_post_meta($attachment_id, '_media_toolkit_url', true);
        if (!empty($cloud_url)) {
            return $cloud_url;
        }

        // Get WordPress URL
        $image_src = wp_get_attachment_image_src($attachment_id, 'large');
        if ($image_src && !empty($image_src[0])) {
            return $image_src[0];
        }

        // Fallback to full size
        return wp_get_attachment_url($attachment_id) ?: '';
    }

    /**
     * Check which fields need to be generated
     */
    private function check_fields_to_generate(array $item, bool $overwrite): array
    {
        $needs = [];

        if ($overwrite || empty($item['alt_text'])) {
            $needs['alt_text'] = true;
        }

        // Check if title is just a filename
        $title = $item['post_title'] ?? '';
        $is_filename = preg_match('/^[a-zA-Z0-9_-]+$/', $title);
        if ($overwrite || empty($title) || $is_filename) {
            $needs['title'] = true;
        }

        if ($overwrite || empty($item['post_excerpt'])) {
            $needs['caption'] = true;
        }

        if ($overwrite || empty($item['post_content'])) {
            $needs['description'] = true;
        }

        return $needs;
    }

    /**
     * Save generated metadata to attachment
     */
    private function save_metadata(int $attachment_id, array $metadata, array $current, bool $overwrite): void
    {
        // Update alt text
        if ($overwrite || empty($current['alt_text'])) {
            update_post_meta($attachment_id, '_wp_attachment_image_alt', $metadata['alt_text']);
        }

        // Update post fields
        $update_data = ['ID' => $attachment_id];
        
        $title = $current['post_title'] ?? '';
        $is_filename = preg_match('/^[a-zA-Z0-9_-]+$/', $title);
        if ($overwrite || empty($title) || $is_filename) {
            $update_data['post_title'] = $metadata['title'];
        }

        if ($overwrite || empty($current['post_excerpt'])) {
            $update_data['post_excerpt'] = $metadata['caption'];
        }

        if ($overwrite || empty($current['post_content'])) {
            $update_data['post_content'] = $metadata['description'];
        }

        if (count($update_data) > 1) {
            wp_update_post($update_data);
        }
    }

    /**
     * Generate metadata for a single image (for Media Library integration)
     */
    public function generate_single(int $attachment_id, bool $overwrite = false): array
    {
        // Get current data
        $post = get_post($attachment_id);
        if (!$post || $post->post_type !== 'attachment' || !str_starts_with($post->post_mime_type, 'image/')) {
            return [
                'success' => false,
                'message' => __('Invalid image attachment', 'media-toolkit'),
            ];
        }

        $item = [
            'ID' => $attachment_id,
            'post_title' => $post->post_title,
            'post_excerpt' => $post->post_excerpt,
            'post_content' => $post->post_content,
            'alt_text' => get_post_meta($attachment_id, '_wp_attachment_image_alt', true),
        ];

        $result = $this->process_item($item, ['overwrite' => $overwrite]);

        if ($result['success'] && !($result['skipped'] ?? false)) {
            // Get updated metadata
            $updated_post = get_post($attachment_id);
            return [
                'success' => true,
                'message' => sprintf(
                    __('Metadata generated using %s', 'media-toolkit'),
                    $result['provider'] ?? 'AI'
                ),
                'metadata' => [
                    'title' => $updated_post->post_title,
                    'alt_text' => get_post_meta($attachment_id, '_wp_attachment_image_alt', true),
                    'caption' => $updated_post->post_excerpt,
                    'description' => $updated_post->post_content,
                ],
            ];
        }

        if ($result['skipped'] ?? false) {
            return [
                'success' => true,
                'message' => __('All fields already filled', 'media-toolkit'),
                'skipped' => true,
            ];
        }

        // Build a detailed error message
        $error_message = '';
        if (!empty($result['error'])) {
            $error_message = $result['error'];
        } elseif (!empty($result['message'])) {
            $error_message = $result['message'];
        } else {
            $error_message = __('Generation failed - no details available', 'media-toolkit');
        }

        return [
            'success' => false,
            'message' => $error_message,
            'error' => $error_message,
        ];
    }

    /**
     * Get start options from AJAX request
     */
    protected function get_start_options_from_request(): array
    {
        return [
            'batch_size' => isset($_POST['batch_size']) ? (int) $_POST['batch_size'] : 10,
            'only_empty_fields' => isset($_POST['only_empty_fields']) ? $_POST['only_empty_fields'] === 'true' : true,
            'overwrite' => isset($_POST['overwrite']) ? $_POST['overwrite'] === 'true' : false,
            'background_mode' => isset($_POST['background_mode']) ? $_POST['background_mode'] === 'true' : false,
        ];
    }

    /**
     * Schedule async batch processing via WP Cron
     */
    public function schedule_async_batch(): void
    {
        // Only schedule if not already scheduled
        if (!wp_next_scheduled(self::CRON_HOOK)) {
            wp_schedule_single_event(time() + 5, self::CRON_HOOK);
            $this->logger->info('ai_metadata', 'Scheduled async batch processing');
        }
    }

    /**
     * Process async batch (cron callback)
     * This runs in the background without browser connection
     */
    public function process_async_batch(): void
    {
        $state = $this->get_state();

        // Don't process if not running
        if ($state['status'] !== 'running') {
            $this->logger->info('ai_metadata', 'Async batch skipped - status: ' . $state['status']);
            return;
        }

        // Check if background mode is enabled
        if (empty($state['options']['background_mode'])) {
            $this->logger->info('ai_metadata', 'Async batch skipped - background mode not enabled');
            return;
        }

        $this->logger->info('ai_metadata', 'Processing async batch...');

        $result = $this->process_batch();

        // Schedule next batch if not complete and still running
        $state = $this->get_state(); // Refresh state
        if (!($result['complete'] ?? false) && $state['status'] === 'running') {
            $this->schedule_async_batch();
        } else {
            $this->logger->info('ai_metadata', 'Async processing finished or stopped');
        }
    }

    /**
     * Stop processing and clear scheduled cron events
     */
    public function stop(): void
    {
        // Clear any scheduled cron events first
        $this->clear_scheduled_events();

        // Call parent stop
        parent::stop();

        $this->logger->info('ai_metadata', 'AI Metadata Generator stopped and cron events cleared');
    }

    /**
     * Pause processing and clear scheduled cron events
     */
    public function pause(): void
    {
        // Clear any scheduled cron events
        $this->clear_scheduled_events();

        // Call parent pause
        parent::pause();
    }

    /**
     * Resume processing and reschedule if in background mode
     */
    public function resume(): void
    {
        parent::resume();

        // If in background mode, reschedule the cron
        $state = $this->get_state();
        if (!empty($state['options']['background_mode']) && $state['status'] === 'running') {
            $this->schedule_async_batch();
        }
    }

    /**
     * Clear all scheduled cron events for this processor
     */
    private function clear_scheduled_events(): void
    {
        // Clear any pending cron events
        $timestamp = wp_next_scheduled(self::CRON_HOOK);
        if ($timestamp) {
            wp_unschedule_event($timestamp, self::CRON_HOOK);
            $this->logger->info('ai_metadata', 'Cleared scheduled cron event');
        }

        // Also clear all instances just to be safe
        wp_clear_scheduled_hook(self::CRON_HOOK);
    }

    /**
     * Check if background processing is currently scheduled
     */
    public function is_background_scheduled(): bool
    {
        return (bool) wp_next_scheduled(self::CRON_HOOK);
    }
}

